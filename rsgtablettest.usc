-- This system works in conjunction with the AndroidRSGDemoZMQ[1] app for 
-- Android. Both the app and this UBX system have a "World Model Agent (WMA)"
-- i.e. in this case single instance of the Robot Scene Graph (RSG). Both 
-- use HDF5 for encoding and decoding. ZMQ is used as network layer.
-- Each update on the RSG is porpageted to the other WMA and vice versa.
--
-- The tablet has GUI elemts to update its WMA, while the UBX system has 
-- a scene setup block that performs an update whenever the setep function is
-- triggered.
--  
-- [1] https://github.com/blumenthal/brics_3d_jni/tree/master/examples/AndroidRSGDemoZMQ

local rsg = require("rsg")

-- create in inctance of the RSG to serve as world model agent 
wm = rsg.WorldModel()


return bd.system
{
   imports = {
      "std_types/stdtypes/stdtypes.so",
      "std_blocks/ptrig/ptrig.so",
      "std_blocks/lfds_buffers/lfds_cyclic.so",
      "std_blocks/lfds_buffers/lfds_cyclic_raw.so",
      "std_blocks/logging/file_logger.so",
      "blocks/zmqreceiverlib.so",
      "blocks/zmqsenderlib.so",
      "types/rsg_types.so",  
      "build/rsgrecieverlib.so",
      "build/rsgsenderlib.so",
      "build/rsgscenesetuplib.so",
      "blocks/irospublisher.so",
   },

   blocks = {
      { name="rsgsender", type="rsg_sender" }, 
      { name="rsgreciever", type="rsg_reciever" },
      { name="publisher", type="zmq_sender" },
      { name="subscriber", type="zmq_receiver" },
      { name="scenesetup", type="rsg_scene_setup" },
      -- we have to explicitly configure the buffers for large message sized (cf. config setion)
      { name="bytestreambuffer1",type="lfds_buffers/cyclic_raw" }, 
      { name="bytestreambuffer2",type="lfds_buffers/cyclic_raw" },
      { name="cyclic_input_trigger", type="std_triggers/ptrig" }, -- we have to poll if something is in the input buffer
      { name="visualization_publisher", type="rosbridge/publisher" }, -- optional for visualization

   },
   
   connections = {
      { src="rsgsender.rsg_out", tgt="bytestreambuffer1" },
      { src="bytestreambuffer1", tgt="publisher.zmq_out" },
                  
      { src="subscriber.zmq_in", tgt="bytestreambuffer2" },
      { src="bytestreambuffer2", tgt="rsgreciever.rsg_in" },
      
      { src="subscriber.zmq_in", tgt="visualization_publisher" },
      
   },
   
   configurations = {
	  { name="rsgsender", config =  { wm_handle={wm = wm:getHandle().wm} } },
	  { name="rsgreciever", config =  { buffer_len=300, wm_handle={wm = wm:getHandle().wm} } },
	  { name="publisher", config = { connection_spec="tcp://*:11511" } },
	  -- The IP for the subscriber has to come from the Android device. 
	  -- Use the WiFi setting menue to obtain it.
	  -- Per default the tablet will publish to port 11411 (and listen to 11511)
    { name="subscriber", config = { connection_spec= "tcp://192.168.1.104:11411"  } },	
    { name="scenesetup", config =  { wm_handle={wm = wm:getHandle().wm} } },
    { name="bytestreambuffer1", config = { element_num=10 , element_size=20000 } },
    { name="bytestreambuffer2", config = { element_num=10 , element_size=20000 } },
    { name="cyclic_input_trigger", config = { period = {sec=0, usec=100000 }, trig_blocks={ { b="#rsgreciever", num_steps=1, measure=0 } } } },	
    { name="visualization_publisher", config = { topic_name="world_model/update_stream" } },				
   },
}
